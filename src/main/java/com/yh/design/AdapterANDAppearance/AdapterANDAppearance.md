<head>适配器和外观模式</head>

<p>适配器：将一个类的接口转换成客户期望的另一个接口，适配器让原本接口不兼容的类
可以合作无间</p>

适配器实现了目标接口，并持有被适配者的实例

客户使用适配器的过程：
    客户通过目标接口调适配器的方法对适配器发出请求
    适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口
    客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用
    
 

对象适配和类的适配器：
    类适配器不是使用组合来适配被适配者，而是继承被适配者和目标类
   
对象适配器和类适配器使用两种不同的适配方法(分别是组合和继承)

适配器和装饰者的区别：
   适配器无需改变任何代码，由适配器进行转换即可
   装饰者模式可以让新行为加入到类中，无需修改现有代码。
   
   但是适配器一定会进行接口的转换，装饰者不会进行接口的转换。装饰者仅仅是进行扩展包装的对象的行为或责任。
   两者看起来很类似，但是意图差别很大。
   
 外观模式：
    提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
    
外观模式和适配器模式的区别;
    适配器一般适配一个接口或对象，外观模式一般是多个对象/接口吗？不是。
    两种模式的区别不在于包装了多少类，而是在于他们的意图。
    适配器的意图是：改变接口符合客户的期望。而外观模式的意图是提供子系统的一个简化接口。
    
外观模式让客户和子系统耦合。
外观模式满足：最少知识原则。
    最少知识原则减少了对象之间的依赖，这会减少软件的维护成本，但是采用这个原则会导致更多的包装类被制造出来，以处理
    和其它组件的沟通，可能会导致复杂度增加和开发时间的增加，并降低运行时的性能。
    
    
    
