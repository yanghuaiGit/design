<h2>这是关于顾客租影片费用计算问题</h2>
<p>这个结构比较简单，复杂在于Customer的statement做了太多的事情，且扩展性不好</p>
<p>如果需要增加电影分类怎么办，在switch里继续添加分类吗，计费规则的变化，必须对statement进行重构</p>
<li>如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。
</li>
<li>重构之前，首先检查自己是否有一套可靠的测试机制，这些测试必须有自我检验能力</li>
<p>分解并重组statement()</p>
展示如何将长长的函数切开，并把较小块的代码移至更适合的类。希望降低代码重复率。

<li>第一个步骤找出代码的逻辑泥团并运用Extract Method，明显的一个逻辑泥团就是switch语句，把它提炼到独立函数中比较好</li>
<p>任何一个重构，在提炼一个函数时，必须知道可能出什么错，如果提炼的不好，就可能给程序引入bug，所以重构之前必须想出安全做法。</p>
<li>首先，在这段代码里找出函数内的局部变量和参数。each和thisAmount，前者并未修改，后者会被修改，任何不会被修改的变量都可以被当成参数传入新的函数，
至于会被修改的变量就需要格外小心。如果只有一个变量被修改，可以把它作为返回值。thisAmount是个临时变量，其值在每次循环起始处被设为0，并且在switch语句之前不会改变
，所以可以直接把新函数的返回值赋给它。</li>
<h2>重构技术就是以微小的步伐修改程序，如果不犯下错误，便容易发现它<h2>

<p>观察抽取出来的amountforv2方法，这个函数使用了来自Rental类的信息，却没有使用来自Customer类的信息</p>
<p>绝大多数情况下，函数应该放在它所使用的数据的所属对象内，所以amountforv2应该移到Rental类去</p>
<p>临时变量可能是个问题，它们只在自己所属的函数中生效，所以它们会助长冗长而复杂的函数</p>
<h2>运用多态取代条件逻辑</h2>
<p>例子中的switch语句，最好不要在另一个对象的属性基础上运用switch语句，如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用</p>
<p>在例子中的switch有两个变量，一个是影片类型一个是租期长度，可为什么要把这个方法转移到Movie中，而不是继续放在Rental中？</p>
<p>因为这个系统可能发生的变化是加入新影片类型，这种变化带有不稳定倾向，如果影片类型有所变化，希望尽量控制它造成的影响，所以选择在Movie对象内计算费用</p>

<p>不同类型的影片有不同的计费，这可以用继承，将此计算方法由子类来完成吗？</p>
<p>有一个小问题，一部影片可以在生命周期内修改自己的分类，一个对象却不能在生命周期内修改自己所属的类，不过还有一个解决办法State模式，听起来又有点类似于Strategy策略模式</p>
这个取决于Price类(所有的Movie继承这个类)究竟代表计费方式还是代表影片的某个状态。在这个阶段，对于模式的选择反映出你对结构的想法。此刻视为影片的某种状态。
<p>为了引入state模式，使用三个重构手法</p>
<li>将与类型相关的行为搬移至State模式内</li>
<li>将switch语句移到Price类</li>
<li>去掉switch语句</li>

<p>第一步针对类型代码，确保任何时候都通过取值函数和设值函数来访问类型代码。多数访问操作来自其他类，它们已经在使用取值函数，但构造函数仍然直接访问价格代码</p>

<p>引入State模式的收获是：</p>
如果此时要修改任何与价格有关的行为，或是添加新的定价标准，或是加入其它取决于价格的行为，程序的修改会容易很多，这个程序的其余部分并不知道我使用了State模式。
如果在一个更复杂的系统中，有十多个与价格相关的函数，程序的修改难易度就会有很大的区别。
<p>从此，修改影片分类结构，或是改变费用计算规则，改变常客积分计算规则，都容易多了</p>

<p>我个人认为这是策略模式，因为所有的计算是Movie持有的对象_price进行计算的，根据不同的策略对象，不同的_Price给不同的结果</p>












